// -*- C++ -*-
//===---------------------------- cmath -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_CMATH
#define _LIBCPP_CMATH

/*
    cmath synopsis

Macros:

    HUGE_VAL
    HUGE_VALF               // C99
    HUGE_VALL               // C99
    INFINITY                // C99
    NAN                     // C99
    FP_INFINITE             // C99
    FP_NAN                  // C99
    FP_NORMAL               // C99
    FP_SUBNORMAL            // C99
    FP_ZERO                 // C99
    FP_FAST_FMA             // C99
    FP_FAST_FMAF            // C99
    FP_FAST_FMAL            // C99
    FP_ILOGB0               // C99
    FP_ILOGBNAN             // C99
    MATH_ERRNO              // C99
    MATH_ERREXCEPT          // C99
    math_errhandling        // C99

namespace std
{

Types:

    float_t                 // C99
    double_t                // C99

// C90

floating_point abs(floating_point x);

floating_point acos (arithmetic x);
float          acosf(float x);
long double    acosl(long double x);

floating_point asin (arithmetic x);
float          asinf(float x);
long double    asinl(long double x);

floating_point atan (arithmetic x);
float          atanf(float x);
long double    atanl(long double x);

floating_point atan2 (arithmetic y, arithmetic x);
float          atan2f(float y, float x);
long double    atan2l(long double y, long double x);

floating_point ceil (arithmetic x);
float          ceilf(float x);
long double    ceill(long double x);

floating_point cos (arithmetic x);
float          cosf(float x);
long double    cosl(long double x);

floating_point cosh (arithmetic x);
float          coshf(float x);
long double    coshl(long double x);

floating_point exp (arithmetic x);
float          expf(float x);
long double    expl(long double x);

floating_point fabs (arithmetic x);
float          fabsf(float x);
long double    fabsl(long double x);

floating_point floor (arithmetic x);
float          floorf(float x);
long double    floorl(long double x);

floating_point fmod (arithmetic x, arithmetic y);
float          fmodf(float x, float y);
long double    fmodl(long double x, long double y);

floating_point frexp (arithmetic value, int* exp);
float          frexpf(float value, int* exp);
long double    frexpl(long double value, int* exp);

floating_point ldexp (arithmetic value, int exp);
float          ldexpf(float value, int exp);
long double    ldexpl(long double value, int exp);

floating_point log (arithmetic x);
float          logf(float x);
long double    logl(long double x);

floating_point log10 (arithmetic x);
float          log10f(float x);
long double    log10l(long double x);

floating_point modf (floating_point value, floating_point* iptr);
float          modff(float value, float* iptr);
long double    modfl(long double value, long double* iptr);

floating_point pow (arithmetic x, arithmetic y);
float          powf(float x, float y);
long double    powl(long double x, long double y);

floating_point sin (arithmetic x);
float          sinf(float x);
long double    sinl(long double x);

floating_point sinh (arithmetic x);
float          sinhf(float x);
long double    sinhl(long double x);

floating_point sqrt (arithmetic x);
float          sqrtf(float x);
long double    sqrtl(long double x);

floating_point tan (arithmetic x);
float          tanf(float x);
long double    tanl(long double x);

floating_point tanh (arithmetic x);
float          tanhf(float x);
long double    tanhl(long double x);

//  C99

bool signbit(arithmetic x);

int fpclassify(arithmetic x);

bool isfinite(arithmetic x);
bool isinf(arithmetic x);
bool isnan(arithmetic x);
bool isnormal(arithmetic x);

bool isgreater(arithmetic x, arithmetic y);
bool isgreaterequal(arithmetic x, arithmetic y);
bool isless(arithmetic x, arithmetic y);
bool islessequal(arithmetic x, arithmetic y);
bool islessgreater(arithmetic x, arithmetic y);
bool isunordered(arithmetic x, arithmetic y);

floating_point acosh (arithmetic x);
float          acoshf(float x);
long double    acoshl(long double x);

floating_point asinh (arithmetic x);
float          asinhf(float x);
long double    asinhl(long double x);

floating_point atanh (arithmetic x);
float          atanhf(float x);
long double    atanhl(long double x);

floating_point cbrt (arithmetic x);
float          cbrtf(float x);
long double    cbrtl(long double x);

floating_point copysign (arithmetic x, arithmetic y);
float          copysignf(float x, float y);
long double    copysignl(long double x, long double y);

floating_point erf (arithmetic x);
float          erff(float x);
long double    erfl(long double x);

floating_point erfc (arithmetic x);
float          erfcf(float x);
long double    erfcl(long double x);

floating_point exp2 (arithmetic x);
float          exp2f(float x);
long double    exp2l(long double x);

floating_point expm1 (arithmetic x);
float          expm1f(float x);
long double    expm1l(long double x);

floating_point fdim (arithmetic x, arithmetic y);
float          fdimf(float x, float y);
long double    fdiml(long double x, long double y);

floating_point fma (arithmetic x, arithmetic y, arithmetic z);
float          fmaf(float x, float y, float z);
long double    fmal(long double x, long double y, long double z);

floating_point fmax (arithmetic x, arithmetic y);
float          fmaxf(float x, float y);
long double    fmaxl(long double x, long double y);

floating_point fmin (arithmetic x, arithmetic y);
float          fminf(float x, float y);
long double    fminl(long double x, long double y);

floating_point hypot (arithmetic x, arithmetic y);
float          hypotf(float x, float y);
long double    hypotl(long double x, long double y);

double       hypot(double x, double y, double z);                // C++17
float        hypot(float x, float y, float z);                   // C++17
long double  hypot(long double x, long double y, long double z); // C++17

int ilogb (arithmetic x);
int ilogbf(float x);
int ilogbl(long double x);

floating_point lgamma (arithmetic x);
float          lgammaf(float x);
long double    lgammal(long double x);

long long llrint (arithmetic x);
long long llrintf(float x);
long long llrintl(long double x);

long long llround (arithmetic x);
long long llroundf(float x);
long long llroundl(long double x);

floating_point log1p (arithmetic x);
float          log1pf(float x);
long double    log1pl(long double x);

floating_point log2 (arithmetic x);
float          log2f(float x);
long double    log2l(long double x);

floating_point logb (arithmetic x);
float          logbf(float x);
long double    logbl(long double x);

long lrint (arithmetic x);
long lrintf(float x);
long lrintl(long double x);

long lround (arithmetic x);
long lroundf(float x);
long lroundl(long double x);

double      nan (const char* str);
float       nanf(const char* str);
long double nanl(const char* str);

floating_point nearbyint (arithmetic x);
float          nearbyintf(float x);
long double    nearbyintl(long double x);

floating_point nextafter (arithmetic x, arithmetic y);
float          nextafterf(float x, float y);
long double    nextafterl(long double x, long double y);

floating_point nexttoward (arithmetic x, long double y);
float          nexttowardf(float x, long double y);
long double    nexttowardl(long double x, long double y);

floating_point remainder (arithmetic x, arithmetic y);
float          remainderf(float x, float y);
long double    remainderl(long double x, long double y);

floating_point remquo (arithmetic x, arithmetic y, int* pquo);
float          remquof(float x, float y, int* pquo);
long double    remquol(long double x, long double y, int* pquo);

floating_point rint (arithmetic x);
float          rintf(float x);
long double    rintl(long double x);

floating_point round (arithmetic x);
float          roundf(float x);
long double    roundl(long double x);

floating_point scalbln (arithmetic x, long ex);
float          scalblnf(float x, long ex);
long double    scalblnl(long double x, long ex);

floating_point scalbn (arithmetic x, int ex);
float          scalbnf(float x, int ex);
long double    scalbnl(long double x, int ex);

floating_point tgamma (arithmetic x);
float          tgammaf(float x);
long double    tgammal(long double x);

floating_point trunc (arithmetic x);
float          truncf(float x);
long double    truncl(long double x);

constexpr float       lerp(float a, float b, float t) noexcept;                   // C++20
constexpr double      lerp(double a, double b, double t) noexcept;                // C++20
constexpr long double lerp(long double a, long double b, long double t) noexcept; // C++20

}  // std

*/

#include <__config>
#include <math.h>
#include <version>
#include <type_traits>
#include <limits>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

#if defined(_LIBCPP_HAS_MUSL_LIBC)

// Get rid of those macros defined in <math.h> in lieu of real functions.
#undef abs
#undef div
#undef acos
#undef asin
#undef atan
#undef atan2
#undef ceil
#undef cos
#undef cosh
#undef exp
#undef fabs
#undef floor
#undef fmod
#undef frexp
#undef ldexp
#undef log
#undef log10
#undef modf
#undef pow
#undef sin
#undef sinh
#undef sqrt
#undef tan
#undef tanh


namespace std 
{
  // Forward declaration of a helper function.  This really should be
  // an `exported' forward declaration.
  template<typename _Tp> _Tp __cmath_power(_Tp, unsigned int);

  template<typename _Tp>
  inline _Tp
    __cmath_abs(_Tp __x)
    {
      return __x < _Tp() ? -__x : __x;
    }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

#if _GLIBCPP_HAVE_ACOSF
  inline float 
  acos(float __x) { return ::acosf(__x); }
#else
  inline float 
  acos(float __x) { return ::acos(static_cast<double>(__x)); }
#endif

//   using ::acos;
  
#if _GLIBCPP_HAVE_ACOSL
  inline long double 
  acos(long double __x) { return ::acosl(__x); }
#else
  inline long double 
  acos(long double __x) { return ::acos(static_cast<double>(__x)); }
#endif

#if _GLIBCPP_HAVE_ASINF
  inline float 
  asin(float __x) { return ::asinf(__x); }
#else
  inline float 
  asin(float __x) { return ::asin(static_cast<double>(__x)); }
#endif

//   using ::asin;

#if _GLIBCPP_HAVE_ASINL
  inline long double 
  asin(long double __x) { return ::asinl(__x); }
#else
  inline long double 
  asin(long double __x) { return ::asin(static_cast<double>(__x)); }
#endif

#if _GLIBCPP_HAVE_ATANF
  inline float 
  atan(float __x) { return ::atanf(__x); }
#else
  inline float 
  atan(float __x) { return ::atan(static_cast<double>(__x)); }
#endif

//   using ::atan;

#if _GLIBCPP_HAVE_ATANL
  inline long double 
  atan(long double __x) { return ::atanl(__x); }
#else
  inline long double 
  atan(long double __x) { return ::atan(static_cast<double>(__x)); }
#endif

#if _GLIBCPP_HAVE_ATAN2F
  inline float 
  atan2(float __y, float __x) { return ::atan2f(__y, __x); }
#else
  inline float 
  atan2(float __y, float __x)
  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }
#endif

//   using ::atan2;

#if _GLIBCPP_HAVE_ATAN2L
  inline long double 
  atan2(long double __y, long double __x) { return ::atan2l(__y, __x); }
#else
  inline long double 
  atan2(long double __y, long double __x) 
  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }
#endif

#if _GLIBCPP_HAVE_CEILF
  inline float 
  ceil(float __x) { return ::ceilf(__x); }
#else
  inline float 
  ceil(float __x) { return ::ceil(static_cast<double>(__x)); }
#endif

//   using ::ceil;

#if _GLIBCPP_HAVE_CEILL
  inline long double 
  ceil(long double __x) { return ::ceill(__x); }
#else
  inline long double 
  ceil(long double __x) { return ::ceil(static_cast<double>(__x)); }
#endif

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

//   using ::cos;

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

#if _GLIBCPP_HAVE_COSHF
  inline float 
  cosh(float __x) { return ::coshf(__x); }
#else
  inline float 
  cosh(float __x) { return ::cosh(static_cast<double>(__x)); }
#endif

//   using ::cosh;

#if _GLIBCPP_HAVE_COSHL
  inline long double 
  cosh(long double __x) { return ::coshl(__x); }
#else
  inline long double 
  cosh(long double __x) { return ::cosh(static_cast<double>(__x)); }
#endif

#if _GLIBCPP_HAVE_EXPF
  inline float 
  exp(float __x) { return ::expf(__x); }
#else
  inline float 
  exp(float __x) { return ::exp(static_cast<double>(__x)); }
#endif

//   using ::exp;

#if _GLIBCPP_HAVE_EXPL
  inline long double 
  exp(long double __x) { return ::expl(__x); }
#else
  inline long double 
  exp(long double __x) { return ::exp(static_cast<double>(__x)); }
#endif

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

//   using ::fabs;

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

#if _GLIBCPP_HAVE_FLOORF
  inline float 
  floor(float __x) { return ::floorf(__x); }
#else
  inline float 
  floor(float __x) { return ::floor(static_cast<double>(__x)); }
#endif

//   using ::floor;

#if _GLIBCPP_HAVE_FLOORL
  inline long double 
  floor(long double __x) { return ::floorl(__x); }
#else
  inline long double 
  floor(long double __x) { return ::floor(static_cast<double>(__x)); }
#endif

#if _GLIBCPP_HAVE_FMODF
  inline float 
  fmod(float __x, float __y) { return ::fmodf(__x, __y); }
#else
  inline float 
  fmod(float __x, float __y)
  { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }
#endif

//   using ::fmod;

#if _GLIBCPP_HAVE_FMODL
  inline long double 
  fmod(long double __x, long double __y) { return ::fmodl(__x, __y); }
#else
  inline long double 
  fmod(long double __x, long double __y) 
  { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }
#endif

#if _GLIBCPP_HAVE_FREXPF
  inline float 
  frexp(float __x, int* __exp) { return ::frexpf(__x, __exp); }
#else
  inline float 
  frexp(float __x, int* __exp) { return ::frexp(__x, __exp); }
#endif

//   using ::frexp;

#if _GLIBCPP_HAVE_FREXPL
  inline long double 
  frexp(long double __x, int* __exp) { return ::frexpl(__x, __exp); }
#else
  inline long double 
  frexp(long double __x, int* __exp) 
  { return ::frexp(static_cast<double>(__x), __exp); }
#endif

#if _GLIBCPP_HAVE_LDEXPF
  inline float 
  ldexp(float __x, int __exp) { return ::ldexpf(__x, __exp); }
#else
  inline float 
  ldexp(float __x, int __exp)
  { return ::ldexp(static_cast<double>(__x), __exp); }
#endif

//   using ::ldexp;

#if _GLIBCPP_HAVE_LDEXPL
  inline long double 
  ldexp(long double __x, int __exp) { return ::ldexpl(__x, __exp); }
#else
  inline long double 
  ldexp(long double __x, int __exp) 
  { return ::ldexp(static_cast<double>(__x), __exp); }
#endif

#if _GLIBCPP_HAVE_LOGF
  inline float 
  log(float __x) { return ::logf(__x); }
#else
  inline float log(float __x)
  { return ::log(static_cast<double>(__x)); }
#endif

//   using ::log;

#if _GLIBCPP_HAVE_LOGL
  inline long double 
  log(long double __x) { return ::logl(__x); }
#else
  inline long double 
  log(long double __x) { return ::log(static_cast<double>(__x)); }
#endif

#if _GLIBCPP_HAVE_LOG10F
  inline float 
  log10(float __x) { return ::log10f(__x); }
#else
  inline float 
  log10(float __x) { return ::log10(static_cast<double>(__x)); }
#endif

//   using ::log10;

#if _GLIBCPP_HAVE_LOG10L
  inline long double 
  log10(long double __x) { return ::log10l(__x); }
#else
  inline long double 
  log10(long double __x) { return ::log10(static_cast<double>(__x)); }
#endif

#if _GLIBCPP_HAVE_MODFF
  inline float 
  modf(float __x, float* __iptr) { return ::modff(__x, __iptr); }
#else
  inline float 
  modf(float __x, float* __iptr)
  {
    double __tmp;
    double __res = ::modf(static_cast<double>(__x), &__tmp);
    *__iptr = static_cast<float>(__tmp);
    return __res;
  }
#endif

//   using ::modf;

#if _GLIBCPP_HAVE_MODFL
  inline long double 
  modf(long double __x, long double* __iptr) { return ::modfl(__x, __iptr); }
#else
  inline long double 
  modf(long double __x, long double* __iptr) 
  { 
    double __tmp;
    double __res = ::modf(static_cast<double>(__x), &__tmp);
    * __iptr = static_cast<long double>(__tmp);
    return __res;
  }
#endif

  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }
  
#if _GLIBCPP_HAVE_POWF
  inline float 
  pow(float __x, float __y) { return ::powf(__x, __y); }
#else
  inline float 
  pow(float __x, float __y)
  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }
#endif

//   using ::pow;

#if _GLIBCPP_HAVE_POWL
  inline long double 
  pow(long double __x, long double __y) { return ::powl(__x, __y); }
#else
  inline long double 
  pow(long double __x, long double __y) 
  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }
#endif

  inline float 
  pow(float __x, int __n)
  { return __pow_helper(__x, __n); }

  inline double 
  pow(double __x, int __i)
  { return __pow_helper(__x, __i); }

  inline long double 
  pow(long double __x, int __n)
  { return __pow_helper(__x, __n); }

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

//   using ::sin;

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

#if _GLIBCPP_HAVE_SINHF
  inline float 
  sinh(float __x) { return ::sinhf(__x); }
#else
  inline float 
  sinh(float __x) { return ::sinh(static_cast<double>(__x)); }
#endif

//   using ::sinh;

#if _GLIBCPP_HAVE_SINHL
  inline long double 
  sinh(long double __x) { return ::sinhl(__x); }
#else
  inline long double 
  sinh(long double __x) { return ::sinh(static_cast<double>(__x)); }
#endif

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

//   using ::sqrt;

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

#if _GLIBCPP_HAVE_TANF
  inline float 
  tan(float __x) { return ::tanf(__x); }
#else
  inline float 
  tan(float __x) { return ::tan(static_cast<double>(__x)); }
#endif

//   using ::tan;

#if _GLIBCPP_HAVE_TANL
  inline long double 
  tan(long double __x) { return ::tanl(__x); }
#else
  inline long double 
  tan(long double __x) { return ::tan(static_cast<double>(__x)); }
#endif

#if _GLIBCPP_HAVE_TANHF
  inline float 
  tanh(float __x) { return ::tanhf(__x); }
#else
  inline float 
  tanh(float __x) { return ::tanh(static_cast<double>(__x)); }
#endif

//   using ::tanh;

#if _GLIBCPP_HAVE_TANHL
  inline long double 
  tanh(long double __x) { return ::tanhl(__x); }
#else
  inline long double 
  tanh(long double __x) { return ::tanh(static_cast<double>(__x)); }
#endif
} 


#if _GLIBCPP_USE_C99
// These are possible macros imported from C99-land. For strict
// conformance, remove possible C99-injected names from the global
// namespace, and sequester them in the __gnu_cxx extension namespace. 
namespace __gnu_cxx
{
  template<typename _Tp>
    int 
    __capture_fpclassify(_Tp __f) { return fpclassify(__f); }

  template<typename _Tp>
    int 
    __capture_isfinite(_Tp __f) { return isfinite(__f); }

  template<typename _Tp>
    int 
    __capture_isinf(_Tp __f) { return isinf(__f); }

  template<typename _Tp>
    int 
    __capture_isnan(_Tp __f) { return isnan(__f); }

  template<typename _Tp>
    int 
    __capture_isnormal(_Tp __f) { return isnormal(__f); }

  template<typename _Tp>
    int 
    __capture_signbit(_Tp __f) { return signbit(__f); }

  template<typename _Tp>
    int 
    __capture_isgreater(_Tp __f1, _Tp __f2)
    { return isgreater(__f1, __f2); }

  template<typename _Tp>
     int 
     __capture_isgreaterequal(_Tp __f1, _Tp __f2) 
     { return isgreaterequal(__f1, __f2); }

  template<typename _Tp>
     int 
     __capture_isless(_Tp __f1, _Tp __f2) { return isless(__f1, __f2); }

  template<typename _Tp>
     int 
     __capture_islessequal(_Tp __f1, _Tp __f2) 
     { return islessequal(__f1, __f2); }

  template<typename _Tp>
     int 
     __capture_islessgreater(_Tp __f1, _Tp __f2) 
     { return islessgreater(__f1, __f2); }

  template<typename _Tp>
     int 
     __capture_isunordered(_Tp __f1, _Tp __f2) 
     { return isunordered(__f1, __f2); }
} 
#endif

#undef fpclassify
#undef isfinite
#undef isinf
#undef isnan
#undef isnormal
#undef signbit
#undef isgreater
#undef isgreaterequal
#undef isless
#undef islessequal
#undef islessgreater
#undef isunordered

#if _GLIBCPP_USE_C99
namespace __gnu_cxx
{
  template<typename _Tp>
    int
    fpclassify(_Tp __f) { return __capture_fpclassify(__f); }

  template<typename _Tp>
    int
    isfinite(_Tp __f) { return __capture_isfinite(__f); }

  template<typename _Tp>
    int 
    isinf(_Tp __f) { return __capture_isinf(__f); }

  template<typename _Tp>
    int 
    isnan(_Tp __f) { return __capture_isnan(__f); }

  template<typename _Tp>
    int 
    isnormal(_Tp __f) { return __capture_isnormal(__f); }

  template<typename _Tp>
    int 
    signbit(_Tp __f) { return __capture_signbit(__f); }

  template<typename _Tp>
    int 
    isgreater(_Tp __f1, _Tp __f2) { return __capture_isgreater(__f1, __f2); }

  template<typename _Tp>
    int 
    isgreaterequal(_Tp __f1, _Tp __f2) 
    { return __capture_isgreaterequal(__f1, __f2); }

  template<typename _Tp>
    int 
    isless(_Tp __f1, _Tp __f2) { return __capture_isless(__f1, __f2); }

  template<typename _Tp>
    int 
    islessequal(_Tp __f1, _Tp __f2) 
    { return __capture_islessequal(__f1, __f2); }

  template<typename _Tp>
    int 
    islessgreater(_Tp __f1, _Tp __f2) 
    { return __capture_islessgreater(__f1, __f2); }

  template<typename _Tp>
    int 
    isunordered(_Tp __f1, _Tp __f2) 
    { return __capture_isunordered(__f1, __f2); }
}

namespace std
{
  using __gnu_cxx::fpclassify;
  using __gnu_cxx::isfinite;
  using __gnu_cxx::isinf;
  using __gnu_cxx::isnan;
  using __gnu_cxx::isnormal;
  using __gnu_cxx::signbit;
  using __gnu_cxx::isgreater;
  using __gnu_cxx::isgreaterequal;
  using __gnu_cxx::isless;
  using __gnu_cxx::islessequal;
  using __gnu_cxx::islessgreater;
  using __gnu_cxx::isunordered;
}

#endif
#endif

_LIBCPP_BEGIN_NAMESPACE_STD


#if defined(_LIBCPP_HAS_MUSL_LIBC)

#else

using ::signbit;
using ::fpclassify;
using ::isfinite;
using ::isinf;
using ::isnan;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isunordered;
using ::isunordered;

#ifndef _AIX
using ::abs;
#endif

#endif

using ::float_t;
using ::double_t;

using ::acos;
using ::acosf;
using ::asin;
using ::asinf;
using ::atan;
using ::atanf;
using ::atan2;
using ::atan2f;
using ::ceil;
using ::ceilf;
using ::cos;
using ::cosf;
using ::cosh;
using ::coshf;

using ::exp;
using ::expf;

using ::fabs;
using ::fabsf;
using ::floor;
using ::floorf;

using ::fmod;
using ::fmodf;

using ::frexp;
using ::frexpf;
using ::ldexp;
using ::ldexpf;

using ::log;
using ::logf;

using ::log10;
using ::log10f;
using ::modf;
using ::modff;

using ::pow;
using ::powf;

using ::sin;
using ::sinf;
using ::sinh;
using ::sinhf;

using ::sqrt;
using ::sqrtf;
using ::tan;
using ::tanf;

using ::tanh;
using ::tanhf;

using ::acosh;
using ::acoshf;
using ::asinh;
using ::asinhf;
using ::atanh;
using ::atanhf;
using ::cbrt;
using ::cbrtf;

using ::copysign;
using ::copysignf;

using ::erf;
using ::erff;
using ::erfc;
using ::erfcf;
using ::exp2;
using ::exp2f;
using ::expm1;
using ::expm1f;
using ::fdim;
using ::fdimf;
using ::fmaf;
using ::fma;
using ::fmax;
using ::fmaxf;
using ::fmin;
using ::fminf;
using ::hypot;
using ::hypotf;
using ::ilogb;
using ::ilogbf;
using ::lgamma;
using ::lgammaf;
using ::llrint;
using ::llrintf;
using ::llround;
using ::llroundf;
using ::log1p;
using ::log1pf;
using ::log2;
using ::log2f;
using ::logb;
using ::logbf;
using ::lrint;
using ::lrintf;
using ::lround;
using ::lroundf;

using ::nan;
using ::nanf;

using ::nearbyint;
using ::nearbyintf;
using ::nextafter;
using ::nextafterf;
using ::nexttoward;
using ::nexttowardf;
using ::remainder;
using ::remainderf;
using ::remquo;
using ::remquof;
using ::rint;
using ::rintf;
using ::round;
using ::roundf;
using ::scalbln;
using ::scalblnf;
using ::scalbn;
using ::scalbnf;
using ::tgamma;
using ::tgammaf;
using ::trunc;
using ::truncf;

using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;

using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;

using ::copysignl;

using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;

#if _LIBCPP_STD_VER > 14
inline _LIBCPP_INLINE_VISIBILITY float       hypot(       float x,       float y,       float z ) { return sqrt(x*x + y*y + z*z); }
inline _LIBCPP_INLINE_VISIBILITY double      hypot(      double x,      double y,      double z ) { return sqrt(x*x + y*y + z*z); }
inline _LIBCPP_INLINE_VISIBILITY long double hypot( long double x, long double y, long double z ) { return sqrt(x*x + y*y + z*z); }

template <class _A1, class _A2, class _A3>
inline _LIBCPP_INLINE_VISIBILITY
typename _EnableIf
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    __promote<_A1, _A2, _A3>
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                     is_same<_A2, __result_type>::value &&
                     is_same<_A3, __result_type>::value)), "");
    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}
#endif

template <class _A1>
_LIBCPP_INLINE_VISIBILITY
_LIBCPP_CONSTEXPR typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) _NOEXCEPT
{
#if __has_builtin(__builtin_isnan)
    return __builtin_isnan(__lcpp_x);
#else
    return isnan(__lcpp_x);
#endif
}

template <class _A1>
_LIBCPP_INLINE_VISIBILITY
_LIBCPP_CONSTEXPR typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) _NOEXCEPT
{
    return isnan(__lcpp_x);
}

template <class _A1>
_LIBCPP_INLINE_VISIBILITY
_LIBCPP_CONSTEXPR typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) _NOEXCEPT
{
#if __has_builtin(__builtin_isinf)
    return __builtin_isinf(__lcpp_x);
#else
    return isinf(__lcpp_x);
#endif
}

template <class _A1>
_LIBCPP_INLINE_VISIBILITY
_LIBCPP_CONSTEXPR typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) _NOEXCEPT
{
    return isinf(__lcpp_x);
}

template <class _A1>
_LIBCPP_INLINE_VISIBILITY
_LIBCPP_CONSTEXPR typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) _NOEXCEPT
{
#if __has_builtin(__builtin_isfinite)
    return __builtin_isfinite(__lcpp_x);
#else
    return isfinite(__lcpp_x);
#endif
}

template <class _A1>
_LIBCPP_INLINE_VISIBILITY
_LIBCPP_CONSTEXPR typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) _NOEXCEPT
{
    return isfinite(__lcpp_x);
}

#if _LIBCPP_STD_VER > 17
template <typename _Fp>
constexpr
_Fp __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept {
    if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
        return __t * __b + (1 - __t) * __a;

    if (__t == 1) return __b;
    const _Fp __x = __a + __t * (__b - __a);
    if (__t > 1 == __b > __a)
    	return __b < __x ? __x : __b;
    else
    	return __x < __b ? __x : __b;
}

constexpr float
lerp(float __a, float __b, float __t)                   _NOEXCEPT { return __lerp(__a, __b, __t); }

constexpr double
lerp(double __a, double __b, double __t)                _NOEXCEPT { return __lerp(__a, __b, __t); }

constexpr long double
lerp(long double __a, long double __b, long double __t) _NOEXCEPT { return __lerp(__a, __b, __t); }

#endif // _LIBCPP_STD_VER > 17

template <class _IntT, class _FloatT,
    bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),
    int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>
_LIBCPP_INLINE_VISIBILITY
_LIBCPP_CONSTEXPR _IntT __max_representable_int_for_float() _NOEXCEPT {
  static_assert(is_floating_point<_FloatT>::value, "must be a floating point type");
  static_assert(is_integral<_IntT>::value, "must be an integral type");
  static_assert(numeric_limits<_FloatT>::radix == 2, "FloatT has incorrect radix");
  static_assert((_IsSame<_FloatT, float>::value || _IsSame<_FloatT, double>::value
                 || _IsSame<_FloatT,long double>::value), "unsupported floating point type");
  return _FloatBigger ? numeric_limits<_IntT>::max() :  (numeric_limits<_IntT>::max() >> _Bits << _Bits);
}

// Convert a floating point number to the specified integral type after
// clamping to the integral types representable range.
//
// The behavior is undefined if `__r` is NaN.
template <class _IntT, class _RealT>
_LIBCPP_INLINE_VISIBILITY
_IntT __clamp_to_integral(_RealT __r) _NOEXCEPT {
  using _Lim = numeric_limits<_IntT>;
  const _IntT _MaxVal = __max_representable_int_for_float<_IntT, _RealT>();
  if (__r >= ::nextafter(static_cast<_RealT>(_MaxVal), INFINITY)) {
    return _Lim::max();
  } else if (__r <= _Lim::lowest()) {
    return _Lim::min();
  }
  return static_cast<_IntT>(__r);
}

_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

#endif  // _LIBCPP_CMATH
